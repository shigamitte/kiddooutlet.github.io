"use strict"; var animator = (() => { var K = Object.defineProperty; var pe = Object.getOwnPropertyDescriptor; var me = Object.getOwnPropertyNames; var fe = Object.prototype.hasOwnProperty; var ce = (e, t) => { for (var o in t) K(e, o, { get: t[o], enumerable: !0 }) }, ue = (e, t, o, r) => { if (t && typeof t == "object" || typeof t == "function") for (let s of me(t)) !fe.call(e, s) && s !== o && K(e, s, { get: () => t[s], enumerable: !(r = pe(t, s)) || r.enumerable }); return e }; var le = e => ue(K({}, "__esModule", { value: !0 }), e); var ze = {}; ce(ze, { animateAppearEffects: () => ie, getActiveVariantHash: () => ae, spring: () => w, startOptimizedAppearAnimation: () => $ }); var de = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], j = new Set(de); var I = (e, t, o) => Math.min(Math.max(o, e), t); var F = e => e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); var k = e => e; var E = "framerAppearId", Ye = "data-" + F(E); var Z = k; var z = e => e * 1e3, b = e => e / 1e3; var G = e => Array.isArray(e) && typeof e[0] == "number"; var v = ([e, t, o, r]) => `cubic-bezier(${e}, ${t}, ${o}, ${r})`, xe = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: v([0, .65, .55, 1]), circOut: v([.55, 0, 1, .45]), backIn: v([.31, .01, .66, -.59]), backOut: v([.33, 1.53, .69, .99]) }; function C(e) { if (e) return G(e) ? v(e) : Array.isArray(e) ? e.map(C) : xe[e] } function B(e, t, o, { delay: r = 0, duration: s, repeat: a = 0, repeatType: n = "loop", ease: p, times: f } = {}) { let i = { [t]: o }; f && (i.offset = f); let m = C(p); return Array.isArray(m) && (i.easing = m), e.animate(i, { delay: r, duration: s, easing: Array.isArray(m) ? "linear" : m, fill: "both", iterations: a + 1, direction: n === "reverse" ? "alternate" : "normal" }) } function q(e, t) { return t ? e * (1e3 / t) : 0 } var ye = 5; function U(e, t, o) { let r = Math.max(t - ye, 0); return q(o - e(r), t - r) } var N = .001, ge = .01, H = 10, Ae = .05, he = 1; function W({ duration: e = 800, bounce: t = .25, velocity: o = 0, mass: r = 1 }) { let s, a; Z(e <= z(H), "Spring duration must be 10 seconds or less"); let n = 1 - t; n = I(Ae, he, n), e = I(ge, H, b(e)), n < 1 ? (s = i => { let m = i * n, c = m * e, l = m - o, d = V(i, n), u = Math.exp(-c); return N - l / d * u }, a = i => { let c = i * n * e, l = c * o + o, d = Math.pow(n, 2) * Math.pow(i, 2) * e, u = Math.exp(-c), y = V(Math.pow(i, 2), n); return (-s(i) + N > 0 ? -1 : 1) * ((l - d) * u) / y }) : (s = i => { let m = Math.exp(-i * e), c = (i - o) * e + 1; return -N + m * c }, a = i => { let m = Math.exp(-i * e), c = (o - i) * (e * e); return m * c }); let p = 5 / e, f = be(s, a, p); if (e = z(e), isNaN(f)) return { stiffness: 100, damping: 10, duration: e }; { let i = Math.pow(f, 2) * r; return { stiffness: i, damping: n * 2 * Math.sqrt(r * i), duration: e } } } var Te = 12; function be(e, t, o) { let r = o; for (let s = 1; s < Te; s++)r = r - e(r) / t(r); return r } function V(e, t) { return e * Math.sqrt(1 - t * t) } var Oe = ["duration", "bounce"], Me = ["stiffness", "damping", "mass"]; function _(e, t) { return t.some(o => e[o] !== void 0) } function ve(e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!_(e, Me) && _(e, Oe)) { let o = W(e); t = { ...t, ...o, velocity: 0, mass: 1 }, t.isResolvedFromDuration = !0 } return t } function w({ keyframes: e, restDelta: t, restSpeed: o, ...r }) { let s = e[0], a = e[e.length - 1], n = { done: !1, value: s }, { stiffness: p, damping: f, mass: i, velocity: m, duration: c, isResolvedFromDuration: l } = ve(r), d = m ? -b(m) : 0, u = f / (2 * Math.sqrt(p * i)), y = a - s, g = b(Math.sqrt(p / i)), M = Math.abs(y) < 5; o || (o = M ? .01 : 2), t || (t = M ? .005 : .5); let h; if (u < 1) { let x = V(g, u); h = A => { let T = Math.exp(-u * g * A); return a - T * ((d + u * g * y) / x * Math.sin(x * A) + y * Math.cos(x * A)) } } else if (u === 1) h = x => a - Math.exp(-g * x) * (y + (d + g * y) * x); else { let x = g * Math.sqrt(u * u - 1); h = A => { let T = Math.exp(-u * g * A), P = Math.min(x * A, 300); return a - T * ((d + u * g * y) * Math.sinh(P) + x * y * Math.cosh(P)) / x } } return { calculatedDuration: l && c || null, next: x => { let A = h(x); if (l) n.done = x >= c; else { let T = d; x !== 0 && (u < 1 ? T = U(h, x, A) : T = 0); let P = Math.abs(T) <= o, se = Math.abs(a - A) <= t; n.done = P && se } return n.value = n.done ? a : A, n } } } var D = (e, t) => `${e}: ${t}`; var O = new Map; function Q(e, t, o, r) { let s = D(e, j.has(t) ? "transform" : t), a = O.get(s); if (!a) return 0; let { animation: n, startTime: p } = a, f = () => { O.delete(s); try { n.cancel() } catch { } }; if (p !== null) { let i = performance.now(); return r.update(() => { o.animation && (o.animation.time = b(performance.now() - i)) }), r.render(f), i - p || 0 } else return f(), 0 } function $(e, t, o, r, s) { let a = e.dataset[E]; if (!a) return; window.HandoffAppearAnimations = Q; let n = D(a, t), p = B(e, t, [o[0], o[0]], { duration: 1e4, ease: "linear" }); O.set(n, { animation: p, startTime: null }); let f = () => { p.cancel(); let i = B(e, t, o, r); document.timeline && (i.startTime = document.timeline.currentTime), O.set(n, { animation: i, startTime: performance.now() }), s && s(i) }; p.ready ? p.ready.then(f).catch(k) : f() } var L = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], we = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, Se = { translateX: "px", translateY: "px", translateZ: "px", x: "px", y: "px", z: "px", perspective: "px", transformPerspective: "px", rotate: "deg", rotateX: "deg", rotateY: "deg" }; function J(e, t) { let o = Se[e]; return !o || typeof t == "string" && t.endsWith(o) ? t : `${t}${o}` } function X(e) { return L.includes(e) } var Pe = (e, t) => L.indexOf(e) - L.indexOf(t); function ee({ transform: e, transformKeys: t }, { enableHardwareAcceleration: o = !0, allowTransformNone: r = !0 }, s, a) { let n = ""; t.sort(Pe); for (let p of t) n += `${we[p] || p}(${e[p]}) `; return o && !e.z && (n += "translateZ(0)"), n = n.trim(), a ? n = a(e, n) : r && s && (n = "none"), n } function Y(e, t) { let o = new Set(Object.keys(e)); for (let r in t) o.add(r); return Array.from(o) } function R(e, t) { let o = t - e.length; if (o <= 0) return e; let r = new Array(o).fill(e[e.length - 1]); return e.concat(r) } var oe = { duration: .001 }, S = { opacity: 1, scale: 1, translateX: 0, translateY: 0, translateZ: 0, x: 0, y: 0, z: 0, rotate: 0, rotateX: 0, rotateY: 0 }; function re(e, t, o, r, s) { return o.delay && (o.delay *= 1e3), o.type === "spring" ? Ve(e, t, o, r, s) : Ke(e, t, o, r, s) } function ke(e, t, o) { let r = {}, s = 0, a = 0; for (let n of Y(e, t)) { let p = e[n] ?? S[n], f = t[n] ?? S[n]; if (p === void 0 || f === void 0) continue; let i = Ie(p, f, o), { duration: m, keyframes: c } = i; m === void 0 || c === void 0 || (m > s && (s = m, a = c.length), r[n] = c) } return { keyframeValuesByProps: r, longestDuration: s, longestLength: a } } function Ve(e, t, o, r, s) { let a = {}, { keyframeValuesByProps: n, longestDuration: p, longestLength: f } = ke(e, t, o); if (!f) return a; let i = { ease: "linear", duration: p, delay: o.delay }, m = s ? oe : i, c = {}; for (let [d, u] of Object.entries(n)) X(d) ? c[d] = R(u, f) : a[d] = { keyframes: R(u, f), options: d === "opacity" ? i : m }; let l = ne(c, r); return l && (a.transform = { keyframes: l, options: m }), a } function De(e) { let { type: t, duration: o, ...r } = e; return { duration: o * 1e3, ...r } } function Ke(e, t, o, r, s) { let a = De(o); if (!a) return; let n = {}, p = s ? oe : a, f = {}; for (let m of Y(e, t)) { let c = e[m] ?? S[m], l = t[m] ?? S[m]; c === void 0 || l === void 0 || (X(m) ? f[m] = [c, l] : n[m] = { keyframes: [c, l], options: m === "opacity" ? a : p }) } let i = ne(f, r); return i && (n.transform = { keyframes: i, options: p }), n } var te = 10; function Ie(e, t, o) { let r = [e, t], s = w({ ...o, keyframes: r }), a = { done: !1, value: r[0] }, n = [], p = 0; for (; !a.done && p < 1e4;)a = s.next(p), n.push(a.value), p += te; r = n; let f = p - te; return { keyframes: r, duration: f, ease: "linear" } } function ne(e, t) { let o = [], r = Object.values(e)[0]?.length; if (!r) return; let s = Object.keys(e); for (let a = 0; a < r; a++) { let n = {}, p = !0; for (let [i, m] of Object.entries(e)) { let c = m[a]; p && (p = c === void 0 || c === S[i]), c !== void 0 && (n[i] = J(i, c)) } let f = ee({ transform: n, transformKeys: s }, {}, p, t); o.push(f) } return o } function ie(e, t, o, r, s, a) { for (let [n, p] of Object.entries(e)) { let { initial: f, animate: i, transformTemplate: m, variantHash: c } = p; if (!f || !i || c && a && c !== a) continue; let { transition: l, ...d } = i, u = re(f, d, l, Ee(m, r), s); if (!u) continue; let y = {}, g = {}; for (let [M, h] of Object.entries(u)) y[M] = h.keyframes, g[M] = h.options; t(`[${o}="${n}"]`, y, g) } } function Ee(e, t) { if (!(!e || !t)) return (o, r) => e.replace(t, r) } function ae(e) { return e ? e.find(o => o.mediaQuery ? window.matchMedia(o.mediaQuery).matches === !0 : !1)?.hash : void 0 } return le(ze); })();
